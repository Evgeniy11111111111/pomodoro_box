import{createStore as e,createEvent as r,is as t,createNode as o,withRegion as a,attach as i,createEffect as n,sample as s,guard as f,scopeBind as c,clearNode as l}from"effector";var d=new Map,u=e=>([r],t)=>e(t,r),k=r();function g(g){var{adapter:p,store:v,source:y=v,target:h=v,clock:m=y,done:w,fail:x=k,finally:E,pickup:P,context:M,key:D,keyPrefix:b="",contract:S}=g;if(!p)throw Error("Adapter is not defined");if(!y)throw Error("Store or source is not defined");if(!h)throw Error("Target is not defined");if(!D&&y.shortName===y.id)throw Error("Key or name is not defined");if(y===h&&!t.store(y))throw Error("Source must be different from target");void 0===g.def&&t.store(y)&&(g.def=y.defaultState);var z="factory"in p?p(g):p,A=D||y.shortName,N=function(r,t){var o=d.get(r);void 0===o&&(o=new Map,d.set(r,o));var a=o.get(t);return void 0!==a||(a=e(null,{serialize:"ignore"}),o.set(t,a)),a}(z.keyArea||z,b+A),K=o(),T=()=>l(K),j=e=>({status:r="fail",params:t,result:o,error:a})=>"done"===r?{status:r,key:A,keyPrefix:b,operation:e,value:"get"===e?o:t}:{status:r,key:A,keyPrefix:b,operation:e,value:"function"==typeof t?void 0:t,error:a};return a(K,(()=>{var t=e([],{serialize:"ignore"}),o=z(b+A,(e=>D(e))),a=i({source:t,effect:u(o.get)}),l=i({source:t,effect:u(o.set)}),d=n((e=>r=>!e||void 0===r||("isData"in e?e.isData(r):e(r))?r:(()=>{throw"getErrorMessages"in e?e.getErrorMessages(r):void 0})())(S)),k=r(),g=k.filterMap((({status:e,key:r,keyPrefix:t,operation:o,value:a})=>"done"===e?{key:r,keyPrefix:t,operation:o,value:a}:void 0)),p=k.filterMap((({status:e,key:r,keyPrefix:t,operation:o,error:a,value:i})=>"fail"===e?{key:r,keyPrefix:t,operation:o,error:a,value:i}:void 0)),v=r(),D=a;t.updates.watch((()=>{D=(e=>{try{return c(e,{safe:!0})}catch(r){return e}})(a)})),s({source:y,clock:m,target:v}),f({source:s(N,v,((e,r)=>[r,e])),filter:([e,r])=>e!==r,target:l.prepend((([e])=>e))}),s({clock:[a.doneData,l],target:N}),s({clock:[a.doneData,N],target:d}),s({clock:d.doneData,target:h}),s({clock:[a.finally.map(j("get")),l.finally.map(j("set")),d.fail.map(j("validate"))],target:k}),E&&s({clock:k,target:E}),w&&s({clock:g,target:w}),s({clock:p,target:x}),M&&t.on(M,(([e],r)=>[void 0===r?e:r])),P?(s({clock:P,fn:()=>{},target:a}),t.on(P,(([e],r)=>[void 0===r?e:r]))):a()})),T.unsubscribe=T}k.watch((e=>console.error(e.error)));export{g as persist};
//# sourceMappingURL=index.js.map
