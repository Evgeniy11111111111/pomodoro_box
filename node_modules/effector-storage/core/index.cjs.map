{"version":3,"file":"index.cjs","sources":["../../src/core/area.ts","../../src/core/index.ts"],"sourcesContent":["import type { Store } from 'effector'\nimport { createStore } from 'effector'\n\n/**\n * Keys areas / namespaces cache\n */\nconst areas = new Map<any, Map<string, Store<any>>>()\n\n/**\n * Get store, responsible for the key in key area / namespace\n */\nexport function getAreaStorage<State>(keyArea: any, key: string): Store<State> {\n  let area = areas.get(keyArea)\n  if (area === undefined) {\n    area = new Map()\n    areas.set(keyArea, area)\n  }\n\n  let store = area.get(key)\n  if (store !== undefined) {\n    return store\n  }\n\n  store = createStore(null, { serialize: 'ignore' })\n  area.set(key, store)\n\n  return store\n}\n","import type { Effect, Subscription } from 'effector'\nimport type {\n  ConfigAdapter,\n  ConfigAdapterFactory,\n  ConfigPersist,\n  ConfigSourceTarget,\n  ConfigStore,\n  Contract,\n  Done,\n  Fail,\n  Finally,\n} from '../types'\nimport {\n  attach,\n  clearNode,\n  createEvent,\n  createEffect,\n  createNode,\n  createStore,\n  guard,\n  is,\n  sample,\n  scopeBind,\n  withRegion,\n} from 'effector'\nimport { getAreaStorage } from './area'\n\n// helper function to swap two function arguments\n// end extract current context from ref-box\nconst contextual =\n  <T, C, R>(fn: (value: T, ctx?: C) => R) =>\n  ([ref]: [C?], value: T) =>\n    fn(value, ref)\n\n// helper function to validate data with contract\nconst contracted =\n  <T>(contract?: Contract<T>) =>\n  (raw: unknown) =>\n    !contract || // no contract -> data is valid\n    raw === undefined || // `undefined` is always valid\n    ('isData' in contract ? contract.isData(raw) : contract(raw))\n      ? (raw as T)\n      : (() => {\n          throw 'getErrorMessages' in contract\n            ? contract.getErrorMessages(raw)\n            : undefined\n        })()\n\n// helper function for safe bind effects to scope\n// since version 22.4.0 there is `safe` option in `scopeBind`,\n// but as long as effector-storage supports 22.0 this helper is required\nconst safeBind = (fx: Effect<any, any, any>) => {\n  try {\n    // @ts-expect-error due to old typings in import\n    return scopeBind(fx, { safe: true })\n  } catch (e) {\n    return fx\n  }\n}\n\n/**\n * Default sink for unhandled errors\n */\nconst sink = createEvent<Fail<any>>()\nsink.watch((payload) => console.error(payload.error))\n\n/**\n * Main `persist` function\n */\nexport function persist<State, Err = Error>(\n  config: Partial<\n    (ConfigAdapter | ConfigAdapterFactory<any>) &\n      ConfigPersist &\n      ConfigStore<State, Err> &\n      ConfigSourceTarget<State, Err>\n  >\n): Subscription {\n  const {\n    adapter: adapterOrFactory,\n    store,\n    source = store,\n    target = store,\n    clock = source,\n    done,\n    fail = sink,\n    finally: anyway,\n    pickup,\n    context,\n    key: keyName,\n    keyPrefix = '',\n    contract,\n  } = config\n\n  if (!adapterOrFactory) {\n    throw Error('Adapter is not defined')\n  }\n  if (!source) {\n    throw Error('Store or source is not defined')\n  }\n  if (!target) {\n    throw Error('Target is not defined')\n  }\n  if (!keyName && source.shortName === (source as any).id) {\n    throw Error('Key or name is not defined')\n  }\n  if (source === target && !is.store(source)) {\n    throw Error('Source must be different from target')\n  }\n\n  // get default value from store, if given\n  // this is used in adapter factory\n  if ((config as any).def === undefined && is.store(source)) {\n    ;(config as any).def = source.defaultState\n  }\n\n  const adapter =\n    'factory' in adapterOrFactory ? adapterOrFactory(config) : adapterOrFactory\n\n  const key = keyName || source.shortName\n  const storage = getAreaStorage<State>(\n    adapter.keyArea || adapter,\n    keyPrefix + key\n  )\n  const region = createNode()\n  const desist = () => clearNode(region)\n\n  const op =\n    (operation: 'get' | 'set' | 'validate') =>\n    ({ status = 'fail', params, result, error }: any): any =>\n      status === 'done'\n        ? {\n            status,\n            key,\n            keyPrefix,\n            operation,\n            value: operation === 'get' ? result : params,\n          }\n        : {\n            status,\n            key,\n            keyPrefix,\n            operation,\n            value: typeof params === 'function' ? undefined : params, // hide internal \"box\" implementation\n            error,\n          }\n\n  // create all auxiliary units and nodes within the region,\n  // to be able to remove them all at once on unsubscription\n  withRegion(region, () => {\n    const ctx = createStore<[any?]>([], { serialize: 'ignore' })\n\n    const value = adapter<State>(keyPrefix + key, (x) => bindedGet(x))\n\n    const getFx = attach({\n      source: ctx,\n      effect: contextual(value.get),\n    }) as any as Effect<void, State, Err>\n\n    const setFx = attach({\n      source: ctx,\n      effect: contextual(value.set),\n    }) as any as Effect<State, void, Err>\n\n    const validateFx = createEffect<unknown, State>(contracted(contract))\n\n    const localAnyway = createEvent<Finally<State, Err>>()\n    const localDone = localAnyway.filterMap<Done<State>>(\n      ({ status, key, keyPrefix, operation, value }) =>\n        status === 'done' ? { key, keyPrefix, operation, value } : undefined\n    )\n    const localFail = localAnyway.filterMap<Fail<Err>>(\n      ({ status, key, keyPrefix, operation, error, value }: any) =>\n        status === 'fail'\n          ? { key, keyPrefix, operation, error, value }\n          : undefined\n    )\n\n    const trigger = createEvent<State>()\n\n    let bindedGet: (raw?: any) => any = getFx\n    ctx.updates.watch(() => {\n      bindedGet = safeBind(getFx)\n    })\n\n    sample({\n      source,\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      clock: clock!, // `clock` is always defined, as long as `source` is defined\n      target: trigger,\n    })\n\n    guard({\n      source: sample(storage, trigger, (current, proposed) => [\n        proposed,\n        current,\n      ]),\n      filter: ([proposed, current]) => proposed !== current,\n      target: setFx.prepend(([proposed]: State[]) => proposed),\n    })\n    sample({ clock: [getFx.doneData, setFx], target: storage as any })\n    sample({ clock: [getFx.doneData, storage], target: validateFx as any })\n    sample({ clock: validateFx.doneData, target })\n\n    sample({\n      clock: [\n        getFx.finally.map(op('get')),\n        setFx.finally.map(op('set')),\n        validateFx.fail.map(op('validate')),\n      ],\n      target: localAnyway,\n    })\n\n    if (anyway) sample({ clock: localAnyway, target: anyway })\n    if (done) sample({ clock: localDone, target: done })\n    sample({ clock: localFail, target: fail })\n\n    if (context) {\n      ctx.on(context, ([ref], payload) => [\n        payload === undefined ? ref : payload,\n      ])\n    }\n\n    if (pickup) {\n      // pick up value from storage ONLY on `pickup` update\n      sample({ clock: pickup, fn: () => undefined, target: getFx })\n      ctx.on(pickup, ([ref], payload) => [\n        payload === undefined ? ref : payload,\n      ])\n    } else {\n      // kick getter to pick up initial value from storage\n      getFx()\n    }\n  })\n\n  return (desist.unsubscribe = desist)\n}\n"],"names":["areas","Map","contextual","fn","ref","value","sink","createEvent","watch","payload","console","error","config","adapter","adapterOrFactory","store","source","target","clock","done","fail","finally","anyway","pickup","context","key","keyName","keyPrefix","contract","Error","shortName","id","is","undefined","def","defaultState","storage","keyArea","area","get","set","createStore","serialize","getAreaStorage","region","createNode","desist","clearNode","op","operation","status","params","result","withRegion","ctx","x","bindedGet","getFx","attach","effect","setFx","validateFx","createEffect","raw","isData","getErrorMessages","contracted","localAnyway","localDone","filterMap","localFail","trigger","updates","fx","scopeBind","safe","e","safeBind","sample","guard","current","proposed","filter","prepend","doneData","map","on","unsubscribe"],"mappings":"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"}