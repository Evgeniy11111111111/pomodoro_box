/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.21.0
 * @flow
 */

import { Unit, Store, Event, Effect, Subscription } from 'effector'
declare interface StorageAdapter {
  <State>(
    key: string,
    update: (raw?: any) => any
  ): {
    get(raw?: any, ctx?: any): State | Promise<State | void> | void,
    set(value: State, ctx?: any): void,
    ...
  };
  keyArea?: any;
  noop?: boolean;
}
declare interface StorageAdapterFactory<AdapterConfig> {
  (config?: AdapterConfig): StorageAdapter;
  factory: true;
}
declare type Contract<Data> =
  | ((raw: mixed) => boolean)
  | {
      isData: (raw: mixed) => boolean,
      getErrorMessages: (raw: mixed) => string[],
      ...
    }
declare type Done<State> = {
  key: string,
  keyPrefix: string,
  operation: 'set' | 'get',
  value: State,
  ...
}
declare type Fail<Err> = {
  key: string,
  keyPrefix: string,
  operation: 'set' | 'get',
  error: Err,
  value?: any,
  ...
}
declare type Finally<State, Err> =
  | {
      ...Done<State>,
      ...{
        status: 'done',
        ...
      },
    }
  | {
      ...Fail<Err>,
      ...{
        status: 'fail',
        ...
      },
    }
declare interface ConfigPersist$1 {
  pickup?: Unit<any>;
  context?: Unit<any>;
  keyPrefix?: string;
  contract?: Contract<any>;
}
declare interface ConfigCommon<State, Err = Error> {
  clock?: Unit<any>;
  done?: Unit<Done<State>>;
  fail?: Unit<Fail<Err>>;
  finally?: Unit<Finally<State, Err>>;
  pickup?: Unit<any>;
  context?: Unit<any>;
  key?: string;
  keyPrefix?: string;
  contract?: Contract<State | void>;
}
declare interface ConfigJustStore<State> {
  store: Store<State>;
}
declare interface ConfigJustSourceTarget<State> {
  source: Store<State> | Event<State> | Effect<State, any, any>;
  target: Store<State> | Event<State> | Effect<State, any, any>;
}
declare type ConfigStore$1<State, Err = Error> = { ... } & ConfigCommon<
  State,
  Err
> &
  ConfigJustStore<State>
declare type ConfigSourceTarget$1<State, Err = Error> = { ... } & ConfigCommon<
  State,
  Err
> &
  ConfigJustSourceTarget<State>
declare type ConfigPersist = { ... } & ConfigPersist$1
declare interface AsyncStorageConfig {
  serialize?: (value: any) => string;
  deserialize?: (value: string) => any;
}
declare type ConfigStore<State, Err = Error> = { ... } & AsyncStorageConfig &
  ConfigStore$1<State, Err>
declare type ConfigSourceTarget<State, Err = Error> = {
  ...
} & AsyncStorageConfig &
  ConfigSourceTarget$1<State, Err>
declare interface Persist {
  <State, Err>(config: ConfigSourceTarget<State, Err>): Subscription;
  <State, Err>(config: ConfigStore<State, Err>): Subscription;
}
declare var async: typeof npm$namespace$async

declare var npm$namespace$async: {|
  (config?: AsyncStorageConfig): StorageAdapter,
  factory: typeof async$factory,
|}
declare var async$factory: true
declare function createPersist(defaults?: ConfigPersist): Persist
declare var persist: Persist
declare export {
  AsyncStorageConfig,
  ConfigPersist,
  ConfigSourceTarget,
  ConfigStore,
  Contract,
  Done,
  Fail,
  Finally,
  Persist,
  StorageAdapter,
  StorageAdapterFactory,
  async,
  createPersist,
  persist,
}
